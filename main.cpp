/* This file is auto generated by C-Sugar @author Steven Dellamore 
URL = https://github.com/Dellamoresteven/C-Sugar */

// author: Steven Dellamore
// date: 2020-3-7
// version: 1.0.0


#include <iostream>
#include <stdlib.h>
#include <fstream>
#include <algorithm>
#include <vector>
#include <string>
#include <cctype>
#include <list>
#include <sys/stat.h>
#include <unistd.h>
#include <functional>
#include <map>
#include <sstream>
#include <iterator>
#include <string>
#include <functional>
#include <iomanip>
#include "boost/program_options.hpp" 
using namespace boost::program_options;

#include "config.cpp"
#include "createTex.cpp"
#include "token.cpp"

using namespace std;
using namespace config;
using namespace createtex;

#define green "\u001b[32m"
#define red "\u001b[31m"
#define normal "\033[0m"

ostream& operator<<(ostream& os, const Header* hd) {
    os << green << std::setw(hd->depth * 8) <<"type: " << hd->typ << std::setw( (50 - hd->typ.length()) ) << " name: " << hd->name << "\n";
    for_each(hd->configMap.begin(), hd->configMap.end(), [&](const std::pair<string,string> &p){
        os << red << std::setw(hd->depth * 8) << "{" << p.first << ": " << std::setw( (56 - p.first.length()) ) << p.second << "}\n" << normal;
    });
    for( int i = 0; i < hd->inner.size(); i++ ) {
        cout << hd->inner[i];
    }
    return os;
}

ostream& operator<<(ostream& os, const varsS* hd) {
    os << green << "name: " << hd->name << " language: " << hd->language << "\n";
    os << red <<"code:\n" << hd->code << "\n" << normal;
    return os;
}

int main(int argc, char* argv[])  {
    /* for later */
    // string outfile = "output.tex";
    // try { 
    //     options_description desc("Options"); 
    //     desc.add_options() 
    //         ("help,h", "Print help messages") 
    //         ("output,o", value(&outfile), "output File Name");
        
    //     variables_map vm; 
    //     try {
    //         store(parse_command_line(argc, argv, desc), vm);
    //         if ( vm.count("help")  ) { 
    //             std::cout << "You should know" << endl;
    //             return 1; 
    //         }
    //         notify(vm);
    //     } catch(error& e) { 
    //         std::cerr << "ERROR: " << e.what() << std::endl << std::endl; 
    //         return -1; 
    //     }
        
        token * tok = new token();
        ifstream commentMakeFile( "CommentMake.txt" );
        string fileName;
        while ( getline( commentMakeFile, fileName ) ) {
            ifstream file( fileName );
            string found;
            while( found != "-1" ) {
                found = tok->getNextComment( file );
                tok->parseLineWithComment( found, file ); 
            }
        }
        std::cout << "HEADER MAP" << std::endl;
        // Printing out the entire headerMap vector with delim: "\n"
        for (auto i = headerMap.begin(); i != headerMap.end(); ++i)
        {
                std::cout << *i << "\n";
        }
        cout << normal;
        std::cout << "\n\nVARS" << std::endl;
        // Printing out the entire vars vector with delim: "\n"
        for (auto i = vars.begin(); i != vars.end(); ++i)
        {
                std::cout << *i << "\n";
        }
        startDoc();
        return 0;
    // } catch(std::exception& e) {
    //     cout << "EERROROR: " << e.what();
    //     return -1;
    // }
}

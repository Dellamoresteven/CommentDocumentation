@header

#inc e

#include "config.cpp"

using namespace std;

class token {
    private: 
    config::Header * currHeader;
    vector<string> validTagList = { "#frontpage", "#class", "#code" };
    vector<string> validTagListIsInner = { "#function" };
    vector<string> validConfigList = { "@author", "@date", 
                                        "@version", "@company", 
                                        "@title", "@location",
                                        "@email", "@name", "@desc",
                                        "@code", "@param", "@return", "@header", 
                                        "@office", "@returns", "@language" };
    public:
    token() {}

    def string getVar( &stream ) {
        string fullLine = "";
        string line;
        int numTabSpace = 0;
        const std::string& chars = "\t\v\f\r ";
        while ( getline( stream, line ) ) {
            auto found = line.find("|");
            auto foundComment = line.find("//");
            if( found != string::npos && foundComment != string::npos ){
                // cout << "fullLine:\n" << fullLine << endl;
                return fullLine;
            } else {
                if( fullLine == "" ) {
                    numTabSpace = line.find_first_not_of(chars);
                    line.erase(0, numTabSpace);
                    fullLine += line;
                } else {
                    int checkTabSpace = line.find_first_not_of(chars);
                    if( checkTabSpace >= numTabSpace ) {
                        line.erase(0, numTabSpace);
                    }
                    fullLine += "\n";
                    fullLine += line;
                }
            }
        }
        cout << "ERROR getVar\n";
        return "-1";
    }

    def string getNextComment( &stream ) {
        string fullLine = "";
        string line;
        while (getline( stream, line )) {
            var found = std::min(line.find("//"), line.find("*"));
            if (found != string::npos) {
                const std::string& chars = "\t\v\f\r ";
                line.erase(0, line.find_first_not_of(chars));
                if(line.at(0) == '/' && line.at(1) == '/'){
                    fullLine += line.substr(2);
                } else if( line.at(0) == '*' && line != "/" && line != "*/" ) {
                    fullLine += line.substr(1);
                } 
                // else {
                //     fullLine += line;
                // }
                var found = line.find("#code");
                if (found != string::npos) {
                    string temp = getVar( stream );
                    // cout << "temp:\n" << temp << endl;
                    fullLine = "//" + fullLine + "\n" + temp;
                    return fullLine;
                }

                if(line.at(line.length() - 1) == '|' || line.at(line.length() - 2) == '|'){
                    fullLine = "//" + fullLine;
                    // cout << "fullLine: " << fullLine << endl << endl;
                    return fullLine;
                }
            }
        }
        return "-1";
    }


    def parseLineWithComment( line, &file ) {
        // cout << "line:\n" << line << endl;
        if( line == "-1" ) return;

        stringstream lineReaderSS( line );
        string word;
        

        auto getSubstance = [&](auto &stream) mutable {
            string name; 
            while( stream >> word  ) {
                if(word == "|") {
                    return name.substr( 0, name.length() - 1 );
                }
                name += word;
                name += " ";
            }
            cout << "UH OHOHH" << endl;
            return name.substr( 0, name.length() - 1 ); 
        };

        while( lineReaderSS >> word ) {
            if( std::find( validTagListIsInner.begin(), validTagListIsInner.end(), word ) != validTagListIsInner.end() ) {
                config::Header * e = new config::Header();
                e->typ = word;
                string longerName;
                lineReaderSS >> longerName;
                size_t found = longerName.find("::"); 
                if (found != string::npos) {
                    for( int i = 0; i < config::headerMap.size(); i++ ) {
                        if(config::headerMap[i]->name == longerName.substr(0,found)){
                            e->depth = config::headerMap[i]->depth + 1;
                            e->language = config::headerMap[i]->language;
                            e->name = longerName.substr(found + 2);
                            config::headerMap[i]->inner.push_back(e);
                        }
                    } 
                }
                currHeader = e;
            } 
            if( std::find( validTagList.begin(), validTagList.end(), word ) != validTagList.end() ) {
                if(word == "#code") {
                    // cout << "line2\n" <<  << endl;
                    config::varsS * e = new config::varsS();
                    e->typ = "#code";
                    lineReaderSS >> e->name;
                    lineReaderSS >> e->language;
                    
                    e->code = "\n\\begin{minted}[fontsize=\\footnotesize]{" + e->language + "}\n" + line.substr(line.find("\n") + 1) + "\n\\end{minted}\n";
                    
                    config::vars.push_back( e );
                } else {
                    config::Header * e = new config::Header();
                    e->typ = word;
                    lineReaderSS >> e->name;
                    config::headerMap.push_back( e );
                    currHeader = e;
                }
            }

            if( currHeader != NULL ) {
                if( std::find( validConfigList.begin(), validConfigList.end(), word ) != validConfigList.end() ) {
                    string temp = word;
                    string value = getSubstance( lineReaderSS );
                    if( temp == "@language" ) {
                        currHeader->language = value;
                    }else {
                        currHeader->configMap.push_back(std::pair<string,string>( temp, value ));
                    }
                }
            }
        }
    }
};
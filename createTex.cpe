#ifndef MY_CREATETEX
#define MY_CREATETEX

@header

#define yellow "\033[1;33m"

#inc e
#include <unordered_map>
#include <boost/bind.hpp>

using namespace std;

namespace createtex {

    static void fixHighlighting(){}

    static def void replace( string& contents, string replace, string replaceWith ) {
        {} // fix the weird syntex highlighting
        auto pos = contents.find(replace);
        while (pos != string::npos) {
            contents.replace(pos, replace.length(), replaceWith);
            pos = contents.find(replace, pos);
        }
    }

    static void WriteHeader() {
        ifstream stream( "templates/startDoc.txt" );
        string contents;
        for (char ch; stream.get(ch); contents.push_back(ch)) {}
        ofstream out("./output/output.tex");
        out << contents;
        out.close();
    }

    static void endDoc() {
        ifstream stream( "templates/endDoc.txt" );
        string contents;
        for (char ch; stream.get(ch); contents.push_back(ch)) {}
        ofstream out("./output/output.tex", std::ios_base::app);
        out << contents;
        out.close();
    }

    static void frontpage( config::Header* header ) {
        var vecReplace = vector string;
        var vecFind = vector string;
        vecReplace.pushv( "DATE", "AUTHOR", "COMPANY", "TITLE", "LOCATION", "EMAIL", "COMPANY", "VERSION" );
        vecFind.pushv( "@date", "@author", "@company", "@title", "@location", "@email", "@company", "@version" );

        ifstream stream( "templates/frontPage.txt" );
        string contents;

        for (char ch; stream.get(ch); contents.push_back(ch)) {}

        for( int i = 0; i < vecFind.size(); i++ ) {
            for( int j = 0; j < header->configMap.size(); j++ ) {
                if(header->configMap.at(j).first == vecFind.at(i)) {
                    replace( contents, vecReplace.at(i), header->configMap.at(j).second );
                    break;
                } else if( (j + 1) == header->configMap.size()) {
                    std::cout << yellow << "Did not Provide " << vecFind.at(i) << std::endl << normal;
                }
            }
        }

        ofstream out("./output/output.tex", std::ios_base::app);
        out << contents;
        out.close();
    }

    static void functionpage( config::Header* header ) {
        var vecReplace = vector string;
        var vecFind = vector string;
        vecReplace.pushv( "AUTHOR", "DESC" );
        vecFind.pushv( "@author", "@desc" );

        ifstream stream( "templates/functionPage.txt" );
        string contents;

        for (char ch; stream.get(ch); contents.push_back(ch)) {}

        replace( contents, "FUNC", header->name );
        for( int i = 0; i < vecFind.size(); i++ ) {
            for( int j = 0; j < header->configMap.size(); j++ ) {
                if(header->configMap.at(j).first == vecFind.at(i)) {
                    replace( contents, vecReplace.at(i), header->configMap.at(j).second );
                    break;
                } else if( (j + 1) == header->configMap.size()) {
                    std::cout << yellow << "Did not Provide " << vecFind.at(i) << std::endl << normal;
                }
            }
        }

        ofstream out("./output/output.tex", std::ios_base::app);
        out << contents;
        out.close();
    }

    static void classpage( config::Header* header ) {
        var vecReplace = vector string;
        var vecFind = vector string;
        vecReplace.pushv( "AUTHOR", "DESC" );
        vecFind.pushv( "@author", "@desc" );

        ifstream stream( "templates/classPage.txt" );
        string contents;

        for (char ch; stream.get(ch); contents.push_back(ch)) {}

        replace( contents, "CLASS", header->name );
        for( int i = 0; i < vecFind.size(); i++ ) {
            for( int j = 0; j < header->configMap.size(); j++ ) {
                if(header->configMap.at(j).first == vecFind.at(i)) {
                    replace( contents, vecReplace.at(i), header->configMap.at(j).second );
                    break;
                } else if( (j + 1) == header->configMap.size()) {
                    std::cout << yellow << "Did not Provide " << vecFind.at(i) << std::endl << normal;
                }
            }
        }



        ofstream out("./output/output.tex", std::ios_base::app);
        out << contents;
        out.close();
        for( int i = 0; i < header->inner.size(); i++ ) {
            functionpage( header->inner[i] );
        }
    }

    static void loopThroughHeaderMap() {
        for_each(config::headerMap.begin(), 
                config::headerMap.end(),
                [](auto &x){
                    // cout << x->typ << endl;
                    if( x->typ == "#frontpage" )
                        frontpage( x );
                    if( x->typ == "#class" ){
                        classpage( x );
                    }
                });
    }

    static void startDoc() {
        fixHighlighting();
        // auto x = config::headerMap;
        WriteHeader();

        loopThroughHeaderMap();

        endDoc();
    }
}

#endif
/* This file is auto generated by C-Sugar @author Steven Dellamore 
URL = https://github.com/Dellamoresteven/C-Sugar */

#ifndef MY_CREATETEX
#define MY_CREATETEX

// author: Steven Dellamore
// date: 2020-3-3
// version: 1.0.0


#define yellow "\033[1;33m"

#include <iostream>
#include <stdlib.h>
#include <fstream>
#include <algorithm>
#include <vector>
#include <string>
#include <cctype>
#include <list>
#include <sys/stat.h>
#include <unistd.h>
#include <functional>
#include <map>
#include <sstream>
#include <iterator>
#include <string>
#include <unordered_map>
#include <boost/bind.hpp>

using namespace std;

namespace createtex {

    static void fixHighlighting(){}

    static void replaceInlines( string& contents, int pos, string language ) {
        string AtLink = contents.substr(pos);
        
        auto foundEnd = AtLink.find_first_of( "}" );
        if( foundEnd != string::npos ) {
            AtLink = AtLink.substr( 0, foundEnd+1 );
            string inlineCode = AtLink.substr( 0, foundEnd );
            auto found = inlineCode.find_first_of( "{" );
            inlineCode = inlineCode.substr( found + 1 );
            string form = "\\mintinline[fontsize=\\footnotesize]{" + language + "}{" + inlineCode + "}";
            contents.replace( pos, AtLink.length(), form );
            return;
        }
    }

    static void replaceLinks( string& contents, int pos ) {
        string AtLink = contents.substr(pos);
        
        auto foundEnd = AtLink.find_first_of( "}" );
        if( foundEnd != string::npos ) {
            AtLink = AtLink.substr( 0, foundEnd+1 );
            string varName = AtLink.substr( 0, foundEnd );
            varName.erase(remove( varName.begin(), varName.end(), ' ' ));
            auto found = varName.find_first_of( "{" );
            varName = varName.substr( found + 1 );
            varName.erase(remove( varName.begin(), varName.end(), ' ' ));
            for_each(config::vars.begin(), config::vars.end(), [&](auto &elem){
                if( elem->name == varName ){
                    contents.replace( pos, AtLink.length(), elem->code );
                    return;
                }
            });
        }
    }

    static void replace( string& contents, string replace, string replaceWith, string language ) {
        auto pos = contents.find(replace);
        // cout << contents << endl;
        while (pos != string::npos) {
            while(true){
                auto found = contents.find( "@link{" );
                if( found != string::npos ) {
                    replaceLinks( contents, found );
                } else {
                    found = contents.find( "@inline{" );
                    if( found != string::npos ) {
                        replaceInlines( contents, found, language );
                    } else {
                        break;
                    }
                }
            }
            contents.replace(pos, replace.length(), replaceWith);
            // cout << contents << endl;
            pos = contents.find(replace, pos);
        }
    }

    static void WriteHeader() {
        ifstream stream( "templates/startDoc.txt" );
        string contents;
        for (char ch; stream.get(ch); contents.push_back(ch)) {}
        ofstream out("./output/output.tex");
        out << contents;
        out.close();
    }

    static void endDoc() {
        ifstream stream( "templates/endDoc.txt" );
        string contents;
        for (char ch; stream.get(ch); contents.push_back(ch)) {}
        ofstream out("./output/output.tex", std::ios_base::app);
        out << contents;
        out.close();
    }

    static void frontpage( config::Header* header ) {
        // vecReplace @TODO
        auto vecReplace = std::vector< string >();
        // vecFind @TODO
        auto vecFind = std::vector< string >();
        vecReplace.push_back( "DATE"); // pushing  "DATE" onto vecReplace
        vecReplace.push_back("AUTHOR"); // pushing "AUTHOR" onto vecReplace
        vecReplace.push_back("COMPANY"); // pushing "COMPANY" onto vecReplace
        vecReplace.push_back("TITLE"); // pushing "TITLE" onto vecReplace
        vecReplace.push_back("LOCATION"); // pushing "LOCATION" onto vecReplace
        vecReplace.push_back("EMAIL"); // pushing "EMAIL" onto vecReplace
        vecReplace.push_back("COMPANY"); // pushing "COMPANY" onto vecReplace
        vecReplace.push_back("VERSION"); // pushing "VERSION" onto vecReplace
        vecReplace.push_back("OFFICE"); // pushing "OFFICE" onto vecReplace
        vecFind.push_back( "@date"); // pushing  "@date" onto vecFind
        vecFind.push_back("@author"); // pushing "@author" onto vecFind
        vecFind.push_back("@company"); // pushing "@company" onto vecFind
        vecFind.push_back("@title"); // pushing "@title" onto vecFind
        vecFind.push_back("@location"); // pushing "@location" onto vecFind
        vecFind.push_back("@email"); // pushing "@email" onto vecFind
        vecFind.push_back("@company"); // pushing "@company" onto vecFind
        vecFind.push_back("@version"); // pushing "@version" onto vecFind
        vecFind.push_back("@office"); // pushing "@office" onto vecFind

        ifstream stream( "templates/frontPage.txt" );
        string contents;

        for (char ch; stream.get(ch); contents.push_back(ch)) {}

        for( int i = 0; i < vecFind.size(); i++ ) {
            for( int j = 0; j < header->configMap.size(); j++ ) {
                if(header->configMap.at(j).first == vecFind.at(i)) {
                    replace( contents, vecReplace.at(i), header->configMap.at(j).second, header->language );
                    break;
                } else if( (j + 1) == header->configMap.size()) {
                    std::cout << yellow << "Did not Provide " << vecFind.at(i) << std::endl << normal;
                }
            }
        }

        ofstream out("./output/output.tex", std::ios_base::app);
        out << contents;
        out.close();
    }

    static void functionpage( config::Header* header ) {
        // vecReplace @TODO
        auto vecReplace = std::vector< string >();
        // vecFind @TODO
        auto vecFind = std::vector< string >();
        vecReplace.push_back( "AUTHOR"); // pushing  "AUTHOR" onto vecReplace
        vecReplace.push_back("DESC"); // pushing "DESC" onto vecReplace
        vecReplace.push_back("HEADER"); // pushing "HEADER" onto vecReplace
        vecFind.push_back( "@author"); // pushing  "@author" onto vecFind
        vecFind.push_back("@desc"); // pushing "@desc" onto vecFind
        vecFind.push_back("@header"); // pushing "@header" onto vecFind

        ifstream stream( "templates/functionPage.txt" );
        ifstream paramStream( "templates/paramPage.txt" );
        string contents;
        string contentsParam;


        for (char ch; stream.get(ch); contents.push_back(ch)) {}
        for (char ch; paramStream.get(ch); contentsParam.push_back(ch)) {}

        replace( contents, "FUNC", header->name, "none" );
        
        for( int i = 0; i < vecFind.size(); i++ ) {
            for( int j = 0; j < header->configMap.size(); j++ ) {
                if(header->configMap.at(j).first == vecFind.at(i)) {
                    replace( contents, vecReplace.at(i), header->configMap.at(j).second, header->language );
                    break;
                } else if( (j + 1) == header->configMap.size()) {
                    std::cout << yellow << "Did not Provide " << vecFind.at(i) << std::endl << normal;
                }
            }
        }

        ofstream out("./output/output.tex", std::ios_base::app);
        out << contents;
        out.close();


        /* PARAMS */
        ofstream out2("./output/output.tex", std::ios_base::app);
        // copyContentsParam @TODO
        auto copyContentsParam = contentsParam;
        bool firstParam = true;
        for( auto const& [key, val] : header->configMap ) {
            if( key == "@param" ) {
                if( firstParam ){
                    out2 << "\n\\textbf{\\large{\\\\Parameters}}:\\\\";
                    firstParam = false;
                }
                int index = val.find(":");
                replace( contentsParam, "PARAMDEF", val.substr(0,index), header->language );
                replace( contentsParam, "DESC", val.substr(index + 2), header->language );
                while(true){
                    auto found = contentsParam.find( "@link{" );
                    if( found != string::npos ) {
                        replaceLinks( contentsParam, found );
                    } else {
                        found = contentsParam.find( "@inline{" );
                        if( found != string::npos ) {
                            replaceInlines( contentsParam, found, header->language );
                        } else {
                            break;
                        }
                    }
                }
                out2 << contentsParam;
                contentsParam = copyContentsParam;
            }
        }
        out2.close();
    
        /* RETURNS */
        ofstream out3("./output/output.tex", std::ios_base::app);
        for( auto const& [key, val] : header->configMap ) {
            if( key == "@returns" ) {
                out3 << "\\textbf{\\large{\\\\Returns}}:\\\\";
                int index = val.find(":");
                if(index != string::npos){
                    out3 << "\\textbf{";
                    out3 << val.substr(0, index);
                    out3 << "}: ";
                    out3 << val.substr(index + 2);
                } else {
                    out3 << "\\textbf{";
                    out3 << val;
                    out3 << "}";
                }
                // replace( contentsParam, "PARAMDEF", val.substr(0,index) );
                // replace( contentsParam, "DESC", val.substr(index+2) );
                // out2 << contentsParam;
                // contentsParam = copyContentsParam;
            }
        }
        out3.close();
        
    }

    static void classpage( config::Header* header ) {
        // vecReplace @TODO
        auto vecReplace = std::vector< string >();
        // vecFind @TODO
        auto vecFind = std::vector< string >();
        vecReplace.push_back( "AUTHOR"); // pushing  "AUTHOR" onto vecReplace
        vecReplace.push_back("DESC"); // pushing "DESC" onto vecReplace
        vecFind.push_back( "@author"); // pushing  "@author" onto vecFind
        vecFind.push_back("@desc"); // pushing "@desc" onto vecFind

        ifstream stream( "templates/classPage.txt" );
        string contents;

        for (char ch; stream.get(ch); contents.push_back(ch)) {}

        replace( contents, "CLASS", header->name, "none" );
        for( int i = 0; i < vecFind.size(); i++ ) {
            for( int j = 0; j < header->configMap.size(); j++ ) {
                if(header->configMap.at(j).first == vecFind.at(i)) {
                    replace( contents, vecReplace.at(i), header->configMap.at(j).second, header->language );
                    break;
                } else if( (j + 1) == header->configMap.size()) {
                    std::cout << yellow << "Did not Provide " << vecFind.at(i) << std::endl << normal;
                }
            }
        }



        ofstream out("./output/output.tex", std::ios_base::app);
        out << contents;
        out.close();
        for( int i = 0; i < header->inner.size(); i++ ) {
            functionpage( header->inner[i] );
        }
    }

    static void loopThroughHeaderMap() {
        for_each(config::headerMap.begin(), 
                config::headerMap.end(),
                [](auto &x){
                    // cout << x->typ << endl;
                    if( x->typ == "#frontpage" )
                        frontpage( x );
                    if( x->typ == "#class" ){
                        classpage( x );
                    }
                });
    }

    static void startDoc() {
        fixHighlighting();

        WriteHeader();

        loopThroughHeaderMap();

        endDoc();
    }
}
// pdflatex -synctex=1 -interaction=nonstopmode --shell-escape output/output.tex
#endif
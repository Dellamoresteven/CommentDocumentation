@header

#inc e
#include <functional>
#include <iomanip>

#include "config.cpp"
#include "createTex.cpp"

using namespace std;
using namespace config;
using namespace createtex;

#define green "\u001b[32m"
#define red "\u001b[31m"
#define normal "\033[0m"

def getNextComment( &stream ) {
    string line;
    while (getline( stream, line )) {
        var found = line.find("//");
        if (found != string::npos) { 
            return pair<string, int>(line, found);
        }
    }
    return pair<string, int>("-1", -1);
}

static Header * currHeader;
static vector<string> validTagList = { "#frontpage", "#class" };
static vector<string> validTagListIsInner = { "#function" };
static vector<string> validConfigList = { "@author", "@date", 
                                        "@version", "@company", 
                                        "@title", "@location",
                                        "@email", "@name", "@desc",
                                        "@code", "@param", "@return", "@header" };


def parseLineWithComment( line ) {
    if( line.second == -1 ) return;

    istringstream lineReaderSS( line.first.substr( line.second ) );
    string word;
    

    auto getSubstance = [&](auto &stream) {
        string name; 
        while( word != "|" && word != "\n" ) {
            stream >> word;
            name += word;
            name += " ";
        }
        return name.substr( 0, name.length() - 3 );
    };

    while( lineReaderSS >> word ) {
        if( std::find( validTagListIsInner.begin(), validTagListIsInner.end(), word ) != validTagListIsInner.end() ) {
            Header * e = new config::Header();
            // headerMap.push_back( e );
            e->typ = word;
            string longerName;
            lineReaderSS >> longerName;
            size_t found = longerName.find("::"); 
            if (found != string::npos) {
                for( int i = 0; i < headerMap.size(); i++ ) {
                    if(headerMap[i]->name == longerName.substr(0,found)){
                        e->depth = headerMap[i]->depth + 1;
                        e->name = longerName.substr(found + 2);
                        headerMap[i]->inner.push_back(e);
                    }
                }
                 // objectTest
                // longerName.substr(found + 2) // functionTest
            }
            currHeader = e;
        } 
        if( std::find( validTagList.begin(), validTagList.end(), word ) != validTagList.end() ) {
            Header * e = new config::Header();
            e->typ = word;
            lineReaderSS >> e->name;
            headerMap.push_back( e );
            currHeader = e;
        }

        if( currHeader != NULL ) {
            if( std::find( validConfigList.begin(), validConfigList.end(), word ) != validConfigList.end() ) {
                string temp = word;
                currHeader->configMap.push_back(std::pair<string,string>(temp, getSubstance( lineReaderSS )));
            }
        }
    }
}

ostream& operator<<(ostream& os, const Header* hd) {
    os << green << std::setw(hd->depth * 8) <<"type: " << hd->typ << std::setw( (50 - hd->typ.length()) ) << " name: " << hd->name << "\n";
    for_each(hd->configMap.begin(), hd->configMap.end(), [&](const std::pair<string,string> &p){
        os << red << std::setw(hd->depth * 8) << "{" << p.first << ": " << std::setw( (56 - p.first.length()) ) << p.second << "}\n" << normal;
    });
    for( int i = 0; i < hd->inner.size(); i++ ) {
        cout << hd->inner[i];
    }
    return os;
}

m {
    ifstream file( "input/text.cpp" );
    pair<string,int> found;
    while( found.second != -1 ) {
        found = getNextComment( file );
        parseLineWithComment( found ); 
    }
    println("HEADER MAP");
    printv(headerMap, "\n");

    startDoc();

    return 0;
}
